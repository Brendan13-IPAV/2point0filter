<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IP First Response 2.0</title>

  <!-- External CSS -->
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* Additional styles for cost and effort display */
    .card-metrics {
      margin-top: 10px;
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    .metric-row {
      margin-bottom: 4px;
    }
    
    .metric-label {
      font-weight: 500;
    }
    
    .metric-value {
      color: var(--text-primary);
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="container">
      <div class="header-content">
        <div class="logo">IP First Response 2.0</div>
        <nav class="nav">
          <a href="index.html">Home</a>
          <a href="#">About</a>
        </nav>
      </div>
    </div>
  </header>

  <div class="container main-content">
    <div id="app">Loading... Please wait while we prepare your options</div>
  </div>

  <footer class="footer">
    <div class="container">
      <p style="text-align: center; font-size: 14px;">&copy; 2025 IP Strategy Finder</p>
    </div>
  </footer>

  <script>
// In the main JavaScript section of strategies.html

Promise.all([
  fetch('strategies.json').then(res => res.json()),
  fetch('preferences.json').then(res => res.json()),
  fetch('multipliermatrix.json').then(res => res.json())
]).then(([strategiesData, preferenceConfigs, multiplierMatrix]) => {

  const ipRightsOptions = [
    { id: 'Patent', label: 'Patents', color: 'patent' },
    { id: 'Trade mark', label: 'Trade marks', color: 'trademark' },
    { id: 'Design', label: 'Design rights', color: 'design' },
    { id: 'PBR', label: 'Plant breeder\'s rights', color: 'pbr' },
    { id: 'Copyright', label: 'Copyright', color: 'copyright' },
    { id: 'Any', label: 'Any IP right', color: 'any' }
  ];

  const situationOptions = [
    { id: 'Accused', label: 'I\'ve been accused of infringing' },
    { id: 'Enforcement', label: 'I believe my IP has been infringed' },
    { id: 'Proactive', label: 'I\'m proactively protecting my IP' },
    { id: 'Professional', label: 'I\'m seeking support of an IP professional' }
  ];

  function IPStrategyFinder() {
    // Get only the primary filters from localStorage (rights and situations)
    const savedState = JSON.parse(localStorage.getItem('ipStrategyState')) || {};
    
    // Check if coming from index page with new selections
    const selectedFromIndex = JSON.parse(localStorage.getItem('ipSelectedRights'));
    
    // Define all possible rights for use as default
    const allRights = ['Patent', 'Trade mark', 'Design', 'PBR', 'Copyright', 'Any'];
    
    const state = {
      loading: true,
      strategies: strategiesData,
      filteredStrategies: [],
      accordions: savedState.accordions || { 
        preferences: true, 
        otherFactors: true, 
        situationFilters: true, 
        ipTypeFilters: true 
      },
      // Use selections from index.html if available, otherwise use saved state or ALL rights
      selectedRights: selectedFromIndex || savedState.selectedRights || allRights,
      selectedSituations: savedState.selectedSituations || ['Enforcement'],
      // Don't load preferences and otherFactors from localStorage - always start fresh
      preferences: {
        timeCommitment: 0,
        investment: 0,
        commercialAgreements: 0,
        thirdPartyServices: 0,
        legalAction: 0
      },
      otherFactors: {
        onlineMarkets: 'neutral',
        domainName: 'neutral',
        importingGoods: 'neutral',
        identifyParty: 'neutral'
      },
      // New properties for situation and IP specific filters
      situationSpecificFilters: {},
      ipTypeSpecificFilters: {}
    };
    
    // Clear the selection from localStorage to avoid affecting future visits
    localStorage.removeItem('ipSelectedRights');

    function init() {
      state.loading = false;
      filterAndRankStrategies();
      render();
    }

    function filterAndRankStrategies() {
      let filtered = state.strategies.slice();

      // Filter by IP rights
      if (state.selectedRights.length > 0) {
        filtered = filtered.filter(strategy => {
          const strategyRights = strategy.right.split('; ');
          return state.selectedRights.some(right =>
            strategyRights.includes(right) ||
            strategyRights.includes('Any') ||
            strategyRights.includes('Any IP right')
          );
        });
      }

      // Filter by situations
      if (state.selectedSituations.length > 0) {
        filtered = filtered.filter(strategy =>
          state.selectedSituations.some(situation =>
            strategy.responseType.includes(situation)
          )
        );
      }

      // Apply scoring using multiplier matrix
      state.filteredStrategies = filtered.map(strategy => {
        // Get base score for this strategy (or use default)
        const baseScore = multiplierMatrix.baseScores[strategy.id] || 
                          multiplierMatrix.baseScores.default || 100;
        
        let currentScore = baseScore;
        let hasZeroMultiplier = false;
        
        // Check for zero multipliers first
        const zeroMultipliers = multiplierMatrix.zeroMultipliers;
        for (const [condition, affectedTags] of Object.entries(zeroMultipliers)) {
          // Parse the condition (e.g., "legalAction_strong_negative")
          const [key, strength, direction] = condition.split('_');
          
          // Check if the user has selected this preference with sufficient strength
          let matches = false;
          if (key in state.preferences) {
            const value = state.preferences[key];
            if (direction === 'negative' && value < -1) matches = true;
            if (direction === 'positive' && value > 1) matches = true;
          }
          
          // Check if any of the affected tags applies to this strategy
          if (matches && strategy.approachTags.some(tag => affectedTags.includes(tag))) {
            hasZeroMultiplier = true;
            break;
          }
        }
        
        // If no zero multiplier applies, calculate score using approach multipliers
        if (!hasZeroMultiplier) {
          // Apply multipliers from preferences based on approach tags
          Object.entries(state.preferences).forEach(([key, value]) => {
            if (value !== 0) {
              // Determine direction
              const direction = value > 0 ? 'positive' : 'negative';
              
              // For each approach tag on the strategy
              strategy.approachTags.forEach(approach => {
                if (multiplierMatrix.approachMultipliers[approach]) {
                  const multiplierKey = `${key}_${direction}`;
                  const multiplier = multiplierMatrix.approachMultipliers[approach][multiplierKey];
                  if (multiplier) {
                    currentScore *= multiplier;
                  }
                }
              });
            }
          });
          
          // Apply multipliers from IP type
          strategy.ipTypeTags.forEach(ipType => {
            if (multiplierMatrix.ipTypeMultipliers[ipType]) {
              Object.entries(state.otherFactors).forEach(([key, value]) => {
                if (value !== 'neutral') {
                  const multiplierKey = `${key}_${value}`;
                  const multiplier = multiplierMatrix.ipTypeMultipliers[ipType][multiplierKey];
                  if (multiplier) {
                    currentScore *= multiplier;
                  }
                }
              });
            }
          });
          
          // Apply strategy-specific multipliers for other factors
          Object.entries(state.otherFactors).forEach(([key, value]) => {
            if (value !== 'neutral') {
              const factorKey = `${key}_${value}`;
              if (multiplierMatrix.otherFactorMultipliers[factorKey] && 
                  multiplierMatrix.otherFactorMultipliers[factorKey][strategy.id]) {
                currentScore *= multiplierMatrix.otherFactorMultipliers[factorKey][strategy.id];
              }
            }
          });
        }
        
        // Calculate final score
        let matchScore;
        if (hasZeroMultiplier) {
          matchScore = 0;
        } else {
          // Ensure score is in 1-100 range
          matchScore = Math.min(100, Math.max(1, currentScore));
        }
        
        return { ...strategy, matchScore };
      }).sort((a, b) => b.matchScore - a.matchScore);
    }

    function createDynamicTitle() {
      const situationMap = {
        'Enforcement': 'enforce',
        'Accused': 'respond to accusations about',
        'Proactive': 'proactively protect',
        'Professional': 'seek professional support for'
      };
      
      let action = 'manage'; // Default
      if (state.selectedSituations.length === 1) {
        action = situationMap[state.selectedSituations[0]];
      }
      
      let rightText = 'intellectual property';
      
      if (state.selectedRights.length === 1) {
        // Just one right selected
        rightText = `a ${state.selectedRights[0].toLowerCase()}`;
      } else if (state.selectedRights.length > 1) {
        // Multiple rights selected - format them more naturally
        if (state.selectedRights.length === 2) {
          // Two rights - use "and" between them
          rightText = `${state.selectedRights[0].toLowerCase()} and ${state.selectedRights[1].toLowerCase()}`;
        } else if (state.selectedRights.length <= 4) {
          // 3-4 rights - list with commas and "and"
          const lastRight = state.selectedRights[state.selectedRights.length - 1].toLowerCase();
          const otherRights = state.selectedRights.slice(0, -1).map(r => r.toLowerCase());
          rightText = `${otherRights.join(', ')} and ${lastRight}`;
        } else {
          // More than 4 rights - keep it simple
          rightText = 'multiple IP rights';
        }
      }
      
      return `Showing: Strategies to ${action} ${rightText}`;
    }

    function render() {
      // Only save primary filters to localStorage
      localStorage.setItem('ipStrategyState', JSON.stringify({
        accordions: state.accordions,
        selectedRights: state.selectedRights,
        selectedSituations: state.selectedSituations
        // Do not save preferences or otherFactors
      }));

      const app = document.getElementById('app');
      app.innerHTML = '';

      const container = document.createElement('div');
      container.className = 'grid';

      const leftCol = document.createElement('div');
      leftCol.appendChild(renderTopPreferences()); // Top preferences
      leftCol.appendChild(renderPreferencesAccordion()); // Regular preferences
      leftCol.appendChild(renderSituationSpecificFilters()); // New situation filters
      leftCol.appendChild(renderIPTypeSpecificFilters()); // New IP type filters
      leftCol.appendChild(renderOtherFactorsAccordion()); // Other factors
      container.appendChild(leftCol);

      const rightCol = document.createElement('div');
      rightCol.appendChild(renderActiveFilters()); // Contains title and clear button
      rightCol.appendChild(renderStrategyCards());
      container.appendChild(rightCol);

      app.appendChild(container);
    }

    function renderTopPreferences() {
      const topPrefs = document.createElement('div');
      topPrefs.className = 'top-preferences';
      topPrefs.style.marginBottom = '20px';
      
      // Add key preferences outside accordion
      const keysToInclude = ['commercialAgreements', 'legalAction'];
      
      keysToInclude.forEach(key => {
        const config = preferenceConfigs.filters[key]; // Use the nested structure
        
        const group = document.createElement('div');
        group.className = 'preference-group';

        const label = document.createElement('label');
        label.className = 'preference-label';
        label.textContent = config.label;
        group.appendChild(label);

        const radioGroup = document.createElement('div');
        radioGroup.className = 'radio-group';
        
        config.options.forEach(opt => {
          const radio = document.createElement('label');
          radio.className = 'radio-button';
          if (state.preferences[key] === opt.value) {
            radio.classList.add('radio-selected');
          }
          radio.textContent = opt.label;
          radio.onclick = () => {
            state.preferences[key] = state.preferences[key] === opt.value ? 0 : opt.value;
            filterAndRankStrategies();
            render();
          };
          radioGroup.appendChild(radio);
        });
        
        group.appendChild(radioGroup);
        topPrefs.appendChild(group);
      });
      
      return topPrefs;
    }

    function renderActiveFilters() {
      const filtersWrapper = document.createElement('div');
      
      // Create dynamic title and clear button container
      const titleContainer = document.createElement('div');
      titleContainer.style.display = 'flex';
      titleContainer.style.justifyContent = 'space-between';
      titleContainer.style.alignItems = 'center';
      titleContainer.style.marginBottom = '20px';
      
      // Create title based on selected rights and situation
      const titleElement = document.createElement('h2');
      titleElement.className = 'page-title';
      titleElement.textContent = createDynamicTitle();
      titleContainer.appendChild(titleElement);
      
      // Add Clear All Filters button
      const resetBtn = document.createElement('button');
      resetBtn.textContent = 'Clear All Filters';
      resetBtn.className = 'reset-button';
      resetBtn.onclick = () => {
        // Reset all non-primary filters
        state.preferences = {
          timeCommitment: 0,
          investment: 0,
          commercialAgreements: 0,
          thirdPartyServices: 0,
          legalAction: 0
        };
        state.otherFactors = {
          onlineMarkets: 'neutral',
          domainName: 'neutral',
          importingGoods: 'neutral',
          identifyParty: 'neutral'
        };
        // Also reset situation-specific and IP-type specific filters if you've added them
        state.situationSpecificFilters = {};
        state.ipTypeSpecificFilters = {};
        filterAndRankStrategies();
        render();
      };
      titleContainer.appendChild(resetBtn);
      
      filtersWrapper.appendChild(titleContainer);
      
      // Create secondary filters section (if any exist)
      const hasSecondaryFilters = Object.values(state.preferences).some(v => v !== 0) || 
                                Object.values(state.otherFactors).some(v => v !== 'neutral');
      
      if (hasSecondaryFilters) {
        const secondaryFiltersTitle = document.createElement('div');
        secondaryFiltersTitle.className = 'filters-section-title';
        secondaryFiltersTitle.textContent = 'Active Filters';
        filtersWrapper.appendChild(secondaryFiltersTitle);
        
        const secondaryFiltersContainer = document.createElement('div');
        secondaryFiltersContainer.className = 'active-filters';
        
        // Add preference filters
        Object.entries(state.preferences).forEach(([key, value]) => {
          if (value !== 0) {
            const config = preferenceConfigs.filters[key];
            const opt = config.options.find(o => o.value === value);
            
            // Use pillTemplate and pillLabel for better display
            let pillText = config.pillTemplate || `${config.label}: ${opt.label}`;
            pillText = pillText.replace('{optionLabel}', opt.pillLabel || opt.label);
            
            const pill = document.createElement('div');
            pill.className = 'filter-pill';
            pill.textContent = pillText;
            
            const remove = document.createElement('span');
            remove.className = 'filter-remove';
            remove.textContent = '×';
            remove.onclick = () => {
              state.preferences[key] = 0;
              filterAndRankStrategies();
              render();
            };
            pill.appendChild(remove);
            secondaryFiltersContainer.appendChild(pill);
          }
        });
        
        // Add other factors filters
        Object.entries(state.otherFactors).forEach(([key, value]) => {
          if (value !== 'neutral') {
            const config = preferenceConfigs.otherFactors[key];
            const opt = config.options.find(o => o.value === value);
            
            // Use pillTemplate and pillLabel for better display
            let pillText = config.pillTemplate || `${config.label}: ${opt.label}`;
            pillText = pillText.replace('{optionLabel}', opt.pillLabel || opt.label);
            
            const pill = document.createElement('div');
            pill.className = 'filter-pill';
            pill.textContent = pillText;
            
            const remove = document.createElement('span');
            remove.className = 'filter-remove';
            remove.textContent = '×';
            remove.onclick = () => {
              state.otherFactors[key] = 'neutral';
              filterAndRankStrategies();
              render();
            };
            pill.appendChild(remove);
            secondaryFiltersContainer.appendChild(pill);
          }
        });
        
        // Add situation-specific filters
        if (state.situationSpecificFilters) {
          Object.entries(state.situationSpecificFilters).forEach(([key, value]) => {
            if (value !== undefined && value !== null && value !== '') {
              // Find which situation this belongs to
              let situationFound = false;
              
              // Check all situations until we find the one containing this filter
              for (const situation of state.selectedSituations) {
                if (preferenceConfigs.situationSpecific[situation] && 
                    preferenceConfigs.situationSpecific[situation][key]) {
                  
                  const config = preferenceConfigs.situationSpecific[situation][key];
                  const opt = config.options.find(o => o.value === value);
                  
                  // Use pillTemplate and pillLabel for better display
                  let pillText = config.pillTemplate || `${config.label}: ${opt.label}`;
                  pillText = pillText.replace('{optionLabel}', opt.pillLabel || opt.label);
                  
                  const pill = document.createElement('div');
                  pill.className = 'filter-pill';
                  pill.textContent = pillText;
                  
                  const remove = document.createElement('span');
                  remove.className = 'filter-remove';
                  remove.textContent = '×';
                  remove.onclick = () => {
                    delete state.situationSpecificFilters[key];
                    filterAndRankStrategies();
                    render();
                  };
                  pill.appendChild(remove);
                  secondaryFiltersContainer.appendChild(pill);
                  
                  situationFound = true;
                  break;
                }
              }
            }
          });
        }
        
        // Add IP-specific filters
        if (state.ipTypeSpecificFilters) {
          Object.entries(state.ipTypeSpecificFilters).forEach(([key, value]) => {
            if (value !== undefined && value !== null && value !== '') {
              // Find which IP type this belongs to
              let ipTypeFound = false;
              
              // Check all IP types until we find the one containing this filter
              for (const ipType of state.selectedRights) {
                if (preferenceConfigs.ipTypeSpecific[ipType] && 
                    preferenceConfigs.ipTypeSpecific[ipType][key]) {
                  
                  const config = preferenceConfigs.ipTypeSpecific[ipType][key];
                  const opt = config.options.find(o => o.value === value);
                  
                  // Use pillTemplate and pillLabel for better display
                  let pillText = config.pillTemplate || `${config.label}: ${opt.label}`;
                  pillText = pillText.replace('{optionLabel}', opt.pillLabel || opt.label);
                  
                  const pill = document.createElement('div');
                  pill.className = 'filter-pill';
                  pill.textContent = pillText;
                  
                  const remove = document.createElement('span');
                  remove.className = 'filter-remove';
                  remove.textContent = '×';
                  remove.onclick = () => {
                    delete state.ipTypeSpecificFilters[key];
                    filterAndRankStrategies();
                    render();
                  };
                  pill.appendChild(remove);
                  secondaryFiltersContainer.appendChild(pill);
                  
                  ipTypeFound = true;
                  break;
                }
              }
            }
          });
        }
        
        filtersWrapper.appendChild(secondaryFiltersContainer);
      }
      
      return filtersWrapper;
    }

    function renderIPTypeSpecificFilters() {
      const wrapper = document.createElement('div');

      // Only show this section if IP types are selected
      if (state.selectedRights.length === 0) {
        return wrapper;
      }
      
      const toggle = document.createElement('div');
      toggle.className = 'accordion-header';
      toggle.style.cursor = 'pointer';
      toggle.innerHTML = '<span class="accordion-arrow" style="display:inline-block; transition: transform 0.3s ease; transform: ' + (state.accordions.ipTypeFilters ? 'rotate(90deg)' : 'rotate(0deg)') + ';">▶</span> IP Type Specific Options';
      toggle.onclick = () => {
        state.accordions.ipTypeFilters = !state.accordions.ipTypeFilters;
        render();
      };
      wrapper.appendChild(toggle);

      if (!state.accordions.ipTypeFilters) return wrapper;

      // Initialize state.ipTypeSpecificFilters if it doesn't exist
      if (!state.ipTypeSpecificFilters) {
        state.ipTypeSpecificFilters = {};
      }

      const accordion = document.createElement('div');
      accordion.className = 'accordion';

   // For each selected IP type, show relevant filters
state.selectedRights.forEach(ipType => {
  if (preferenceConfigs.ipTypeSpecific[ipType]) {
    // Add a subheading for the IP type
    const ipTypeHeading = document.createElement('div');
    ipTypeHeading.className = 'preference-group';
    ipTypeHeading.innerHTML = `<h4 style="margin-top: 15px; margin-bottom: 10px;">${ipType}-specific options</h4>`;
    accordion.appendChild(ipTypeHeading);
    
    // Add filters for this IP type
    Object.entries(preferenceConfigs.ipTypeSpecific[ipType]).forEach(([filterKey, config]) => {
      const group = document.createElement('div');
      group.className = 'preference-group';

      const label = document.createElement('label');
      label.className = 'preference-label';
      label.textContent = config.label;
      group.appendChild(label);

      const radioGroup = document.createElement('div');
      radioGroup.className = 'radio-group';
      
      config.options.forEach(opt => {
        const radio = document.createElement('label');
        radio.className = 'radio-button';
        if (state.ipTypeSpecificFilters[filterKey] === opt.value) {
          radio.classList.add('radio-selected');
        }
        radio.textContent = opt.label;
        radio.onclick = () => {
          if (state.ipTypeSpecificFilters[filterKey] === opt.value) {
            // If clicked again, deselect
            delete state.ipTypeSpecificFilters[filterKey];
          } else {
            // Otherwise select
            state.ipTypeSpecificFilters[filterKey] = opt.value;
          }
          filterAndRankStrategies();
          render();
        };
        radioGroup.appendChild(radio);
      });
      
      group.appendChild(radioGroup);
      accordion.appendChild(group);
    });
  }
});

      wrapper.appendChild(accordion);
      return wrapper;
    }

    function renderStrategyCards() {
      const list = document.createElement('div');
      list.className = 'card-grid';
    
      const activePrefs = Object.values(state.preferences).filter(v => v !== 0).length;
      const activeFactors = Object.values(state.otherFactors).filter(v => v !== 'neutral').length;
      const showUnknown = (activePrefs + activeFactors) < 2;
    
      state.filteredStrategies.forEach((strategy, index) => {
        const card = document.createElement('div');
        card.className = 'strategy-card';
        card.style.opacity = '0';
        card.style.transition = 'transform 0.6s ease, opacity 0.6s ease';
        setTimeout(() => { card.style.opacity = '1'; }, 50);
    
        // Change default relevancy from "Unknown" to "Possible"
        let matchLabel = 'Possible';
        let relevanceClass = 'medium'; // mid-green
        const score = strategy.matchScore;
        
        if (score === 0) {
          matchLabel = 'Not Applicable';
          relevanceClass = 'not-applicable';
        } else if (score >= 90) {
          matchLabel = 'Highly Likely'; 
          relevanceClass = 'very-high';
        } else if (score >= 75) {
          matchLabel = 'Likely'; 
          relevanceClass = 'high';
        } else if (score >= 50) {
          matchLabel = 'Possible'; 
          relevanceClass = 'medium';
        } else if (score >= 25) {
          matchLabel = 'Unlikely'; 
          relevanceClass = 'low';
        } else {
          matchLabel = 'Probably Not-Applicable'; 
          relevanceClass = 'very-low';
        }
        
        // Apply the relevancy border color
        card.classList.add(`border-${relevanceClass}`);
    
        // Create tag HTML
        let tagHtml = '';
        
        // 1. IP Type Tags
        if (strategy.ipTypeTags && strategy.ipTypeTags.length > 0) {
          tagHtml += '<div class="tag-category"><span class="tag-category-label">Specific to:</span>';
          strategy.ipTypeTags.forEach(tag => {
            const tagClass = tag.toLowerCase().replace(/\s+/g, '-');
            tagHtml += `<span class="tag ip-tag ${tagClass}-tag">${tag}</span>`;
          });
          tagHtml += '</div>';
        }
        
        // 2. Approach Tags
        if (strategy.approachTags && strategy.approachTags.length > 0) {
          tagHtml += '<div class="tag-category"><span class="tag-category-label">Approach:</span>';
          strategy.approachTags.forEach(tag => {
            const tagClass = tag.toLowerCase().replace(/\s+/g, '-');
            tagHtml += `<span class="tag approach-tag ${tagClass}-tag">${tag}</span>`;
          });
          tagHtml += '</div>';
        }
        
        // Response Type Tags are removed as requested
    
        // Get cost, effort and resolution text directly from the JSON
        // Fallback to placeholders if not present in the JSON
        const costText = strategy.costText || "Cost varies based on complexity";
        const effortText = strategy.effortText || "Time requirement varies";
        const resolutionText = strategy.resolutionText || "Success rate varies by case";
    
        // Include description with cost and effort tags WITH the new tag categories
        card.innerHTML = `
          <div class="relevancy">
            <span class="relevancy-label">Applicability:</span>
            <span class="relevancy-badge ${relevanceClass}">${matchLabel}</span>
          </div>
          <div class="strategy-overtitle">${strategy.overtitle}</div>
          <h3 class="strategy-title">${strategy.title}</h3>
          <p class="strategy-description">${strategy.description}</p>
          
          <div class="strategy-tags">
            ${tagHtml}
          </div>
          
          <div class="card-metrics">
            <div class="metric-row">
              <span class="metric-label">Estimated cost:</span>
              <span class="metric-value">${costText}</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Estimated effort:</span>
              <span class="metric-value">${effortText}</span>
            </div>
            <div class="metric-row">
              <span class="metric-label">Rate of resolution:</span>
              <span class="metric-value">${resolutionText}</span>
            </div>
          </div>
        `;
        list.appendChild(card);
      });
    
      return list;
    }

    return { init };
  }

  const app = IPStrategyFinder();
  app.init();

  // Add "Change IP Rights" link
  const changeIPRightsLink = document.createElement('a');
  changeIPRightsLink.href = 'index.html';
  changeIPRightsLink.textContent = 'Start Over with Different IP Rights';
  changeIPRightsLink.style.color = 'var(--text-secondary)';
  changeIPRightsLink.style.textDecoration = 'none';
  changeIPRightsLink.style.fontSize = '14px';
  changeIPRightsLink.style.display = 'inline-block';
  changeIPRightsLink.style.marginTop = '20px';
  changeIPRightsLink.style.marginBottom = '20px';

  // Add to page above the app
  document.getElementById('app').before(changeIPRightsLink);
  
}).catch(err => {
  console.error('Error loading data:', err);
  document.getElementById('app').textContent = 'Failed to load data.';
});
    
  </script>
</body>
</html>
